 序列化⚡
# java本身序列化机制问题
- 1）序列化结果比较大、传输效率低
- 2) 不能跨语言对接

> 由于上边的原因，早期xml编码就称为了序列化的主流，（1方面跨语言、2方面序列化后好理解） ，以至于基于xml的soap协议及对应的webService 框架在那一段时间比较流行

> 到现在json的简单文本格式编码的HTTP REST接口又基本上取代了复杂的Web Service 几口，称为了分布式架构的首要选择。json 出现的问题是（占的空间大、性能低），于是乎二进制的编码协议出现了MessagePack。
   
**注意**：恰当的选择序列化可以提供系统的通用性、健壮性、安全性、优化性能。同时还能让系统更加易于调试和扩展

# 序列化和反序列化的概念
1）把对象转化为字节序列的过程称为对象的序列化
2）反之😂，就是反序列化

# 怎么去实现一个序列化
1）实现Serializable接口
2) ObjectInputStream :  
3）ObjectOutputStream :
# 问题
## serialVersionUID的作用
`反序列化`的时候会比较序列后`文件中的uid`与定义在`类中uid`比较，不一样就报错。推荐手动写一个private的uid,默认生成的在类文件属性变更时会变化，可能导致反序列化出错

## 静态变量序列化
序列化并不保存静态变量的状态
## transient关键字
类属性上加上`transient`，此属性不参与序列化
## 父子类问题
子类实现了序列化接口，父类没实现，那么父类的属性将不会被序列化
## 序列化后的存储问题
对同一个对象进行多次写入，第二次的存储结果比第一次多了5个字节，实际上是多了一个引用关系
## 深克隆和浅克隆
浅克隆: 被克隆的对象与原来的对象的值相同，所有的引用对象仍是指向原来的引用地址 
深克隆: 被克隆的对象与原来的对象的值相同，所有的引用对象都会指向被复制过来的新对象，即，`深拷贝把要复制的对象所引用的对象都复制了一遍`

# 主流的序列化技术
JSON/Hession(2)/xml/protobuf/kryo/MsgPack/FST/thrift/protostuff/Avro

# 源码地址
[github地址](https://github.com/anhusky/rpc-base) 
